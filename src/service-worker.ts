/// <reference lib="webworker" />
/// <reference types="workbox-routing" />
/// <reference types="workbox-core" />
/// <reference types="workbox-expiration" />
/// <reference types="workbox-precaching" />
/// <reference types="workbox-strategies" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Use clientsClaim() to take control of all pages immediately
clientsClaim();

// Precache all assets generated by the build process
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing for SPA
const fileExtensionRegexp = /\.[^/]+$/;
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html
  ({ request, url }: { request: Request; url: URL }) => {
    // If this is a navigation request, skip handling
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a file (has extension), skip
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want this to be handled by the SPA
    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// Cache images with a Cache First strategy for longer period
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      // Ensure we don't keep more than 60 images in the cache
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache CSS and JS with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Cache font files
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache API requests with a Network First strategy
registerRoute(
  ({ url }) => url.pathname.includes('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Enhanced notification click handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Extract notification data
  const notificationData = event.notification.data || {};
  
  // Focus on or open a window with appropriate navigation
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clientList) => {
      // Try to find an already open window
      for (const client of clientList) {
        if ('focus' in client) {
          // Navigate to the appropriate route based on notification type
          if (notificationData.type === 'reminder' && notificationData.taskId) {
            // For task reminders, navigate to that specific task
            client.postMessage({
              type: 'NOTIFICATION_CLICKED',
              notificationType: 'reminder',
              taskId: notificationData.taskId
            });
            return client.focus();
          } else if (notificationData.type === 'daily') {
            // For daily summary, navigate to today's view
            client.postMessage({
              type: 'NOTIFICATION_CLICKED',
              notificationType: 'daily'
            });
            return client.focus();
          }
          
          // Default: just focus the client
          return client.focus();
        }
      }
      
      // If no open clients, open a new window
      if (self.clients.openWindow) {
        let url = '/';
        
        // Add query parameters for specific views
        if (notificationData.type === 'daily') {
          url = '/?view=calendar';
        } else if (notificationData.type === 'reminder' && notificationData.taskId) {
          url = `/?taskId=${notificationData.taskId}`;
        }
        
        return self.clients.openWindow(url);
      }
    })
  );
});

// Enhanced background sync for offline data
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-tasks') {
    event.waitUntil(syncPendingOperations());
  }
});

async function syncPendingOperations() {
  console.log('Background sync started');
  
  try {
    // Attempt to get all clients
    const clients = await self.clients.matchAll({ type: 'window' });
    
    // Message a client to handle the sync (if any are available)
    if (clients.length > 0) {
      clients[0].postMessage({ type: 'BACKGROUND_SYNC_STARTED' });
      
      // Wait for a response or timeout
      const timeout = setTimeout(() => {
        console.log('Background sync timed out waiting for client response');
        clients[0].postMessage({ type: 'BACKGROUND_SYNC_COMPLETE', success: false });
      }, 30000); // 30 second timeout
      
      // Listen for completion message
      self.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'BACKGROUND_SYNC_DONE') {
          clearTimeout(timeout);
          console.log('Background sync completed successfully');
          clients[0].postMessage({ type: 'BACKGROUND_SYNC_COMPLETE', success: true });
        }
      }, { once: true });
      
    } else {
      // No clients available, use the offline cache fallback
      console.log('No active clients, using fallback sync method');
      await syncFromServiceWorker();
    }
  } catch (error) {
    console.error('Error during background sync:', error);
  }
}

async function syncFromServiceWorker() {
  try {
    const cache = await caches.open('offline-operations');
    const requests = await cache.keys();
    
    for (const request of requests) {
      try {
        const response = await cache.match(request);
        if (!response) continue;
        
        const data = await response.json();
        
        // Attempt to send the data to the server with retry
        let success = false;
        let attempts = 0;
        const maxAttempts = 5;
        
        while (!success && attempts < maxAttempts) {
          attempts++;
          
          try {
            // Calculate exponential backoff delay
            const delay = Math.min(1000 * (2 ** attempts) + Math.random() * 1000, 30000);
            
            if (attempts > 1) {
              await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            const serverResponse = await fetch(request.url, {
              method: request.method || 'POST',
              headers: {
                'Content-Type': 'application/json',
                ...request.headers
              },
              body: JSON.stringify(data),
            });
            
            if (serverResponse.ok) {
              // If successful, remove from offline cache
              await cache.delete(request);
              success = true;
              console.log(`Sync operation successful after ${attempts} attempt(s)`);
            } else {
              console.log(`Server returned error status: ${serverResponse.status}`);
            }
          } catch (fetchError) {
            console.error(`Sync attempt ${attempts} failed:`, fetchError);
          }
        }
        
        if (!success) {
          console.error(`Failed to sync operation after ${maxAttempts} attempts`);
          // The operation remains in the cache for future sync attempts
        }
      } catch (error) {
        console.error('Error processing cached operation:', error);
      }
    }
  } catch (error) {
    console.error('Error during service worker sync:', error);
  }
}

// When a fetch fails during offline mode, respond with custom offline page
const offlineResponse = new Response(
  '<html><head><title>Offline</title><style>body{font-family:sans-serif;text-align:center;padding:20px;}h1{color:#f97316;}</style></head><body><h1>You are offline</h1><p>But don\'t worry! You can still use Khonja and your changes will be synced when you\'re back online.</p></body></html>',
  {
    headers: { 'Content-Type': 'text/html' },
  }
);

self.addEventListener('fetch', (event) => {
  // Let Workbox handle most of the routing
  if (event.request.mode === 'navigate' && !navigator.onLine) {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html') || Promise.resolve(offlineResponse);
      })
    );
  }
});

// Listen for the 'message' event to handle cache updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
